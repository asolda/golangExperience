import java.io.*;
import java_cup.runtime.*;
import java.util.*;

 

parser code {:
    public void syntax_error(Symbol cur_token){
	System.err.println("Syntax error at "+cur_token);
    }
    public static void newScope(){
	typenames.push(new HashSet<String>());
    }
    public static void deleteScope(){
	typenames.pop();
    }
    public static boolean lookupType(String name){
	for (HashSet<String> scope: typenames)
	    if (scope.contains(name)) return true;
	return false;
    }
    public static void addType(String name){
	typenames.peek().add(name);
    }
    public static LinkedList<HashSet<String>> typenames = new LinkedList<HashSet<String>>();
    public Parser(Lexer lex, ComplexSymbolFactory sf) {
	super(lex,sf);
    }

    public static void visita(Node<String> n){
	if(n.getChildren().size()==0){
		System.out.println(n.getData());
		return;
	}
	for(int i=0;i<n.getChildren().size();i++){
		visita(n.getChildren().get(i));
	}
	System.out.println(n.getData());
    }

    public static void main(String args[]) {
	try {
	    Lexer lexer = new Lexer(new FileReader(args[0]));
	    // start parsing
	    Parser p = new Parser(lexer);
	    System.out.println("Parser runs: ");
            newScope();
		
            p.parse();

	
	    System.out.println("Parsing finished!");
	} catch (Exception e) {
	    e.printStackTrace();
	} 
    }
:};

terminal BREAK, DEFAULT, FUNC, INTERFACE, SELECT, ERROR;
terminal ERROR_STRING,OCTAL_LITERAL,RUNE,INT16,UINT8,UINT16,STRING,HEX_LITERAL;
terminal COMPLEX64,DECIMAL_LITERAL,INT,FLOAT_LITERAL,BYTE,UINTPTR;
terminal IDENTIFIER, INT32, INT64,UINT, COMMENT,UINT32,UINT64,SINGLEQUOTE,STRING_LITERAL,IMAGINARY_LITERAL,COMPLEX128,INT8,FLOAT32, FLOAT64;
terminal CASE, DEFER, GO, MAP, STRUCT;
terminal CHAN, ELSE, GOTO, PACKAGE, SWITCH;
terminal CONST, FALLTHROUGH, IF, RANGE, TYPE;
terminal CONTINUE, FOR, IMPORT, RETURN, VAR;
terminal EQ, EQEQ, PLUS, MINUS, TIME, AND, PLUSEQ, ANDEQ, ANDAND, NOTEQ;
terminal RO, RC, OR, MINUSEQ, OREQ, OROR, AO, AOEQ, OS, CS, CAP, TIMEEQ;
terminal CAPEQ, AOMINUS, AC, ACEQUALS, BRACEO, BRACEC, DIV, AOAO, DIVEQ, AOAOEQ, PLUSPLUS;
terminal TPEQ, COMMA, SEMICOLON, PERC, ACAC, PERCEQ, ACACEQ, MINUSMINUS, NOT;
terminal POINTPOINTPOINT, POINT, TP, ANDCAP, ANDCAPEQ, CONSTANT; 

non terminal  program;
non terminal  logic_operator;
non terminal  if_statement;
non terminal  statement;
non terminal  declaration_statement;
non terminal  assignment_statement; 
non terminal  value_numeric;
non terminal  value_string;
non terminal  type_def_numeric;
non terminal  type_def_string;
non terminal  condition;
non terminal  body;
non terminal  composit_condition;
non terminal  composit_statement;
non terminal  string_statement;
non terminal  package_statement;
non terminal  else_statement;

start with program;

program 
	::= package_statement:p composit_statement:lista  {: 
	Node<String> radice = new Node<String>("Program"); 
	Node<String> pr = (Node<String>) p; radice.addChild(pr,radice);   
	ArrayList<Node<String>> l = (ArrayList<Node<String>>) lista;
	for(int i=0;i<l.size();i++){ 
		radice.addChild(l.get(i),radice);
	}
	System.out.println("------------------------------------");
        
        radice.visita(radice);
	
	:}
;

package_statement 
	::= PACKAGE IDENTIFIER:v  {: Node<String> pack=new Node<String>("package"); Node<String> identifier =new Node<String>("Identifier"); String value = (String) v; identifier.addChild(value,identifier); pack.addChild(identifier,pack); RESULT=pack;  :}
;

statement
	::=declaration_statement {: Node<String> dn = new Node<String>("declaration-Node"); RESULT = dn;:}
	| assignment_statement {: Node<String> an = new Node<String>("assignment-Node"); RESULT = an; :}
	| if_statement:ifn {: Node<String> ifnode= (Node<String>) ifn; RESULT=ifnode; :}

	| if_statement:ifn else_statement:elsen {:Node<String> ifElseNode = new Node<String>("if-else-Node");
						Node<String> ifnode= (Node<String>) ifn;
						Node<String> elsenode= (Node<String>) elsen;
						ifElseNode.addChild(ifnode,ifElseNode);
						ifElseNode.addChild(elsenode,ifElseNode);
						 RESULT = ifElseNode;   :}
	   
;


composit_statement
	::= statement:n composit_statement:cl  {: 
	ArrayList<Node<String>> completeList = new ArrayList<Node<String>>();
	Node<String> node = (Node<String>) n;
	Node<String> st =new Node<String> ("Statement");
	st.addChild(node,st);
	ArrayList<Node<String>> new_cl = (ArrayList<Node<String>>) cl;
	for (int i=0;i<new_cl.size();i++){
	completeList.add(new_cl.get(i));
	}
	completeList.add(st);
	
 	RESULT=completeList; 
	
	:}

	| statement:n {:
		Node<String> node = (Node<String>) n; 
		ArrayList<Node<String>> ll = new ArrayList<Node<String>>(); 
		Node<String> st =new Node<String> ("Statement");
		st.addChild(node,st);  
		ll.add(st);
		RESULT=ll;  :}
;

if_statement
	::=IF composit_condition body:lista   {: 
		Node<String> nodo = new Node<String>("if");
		ArrayList<Node<String>> list= (ArrayList<Node<String>>) lista;
		for(int i=0;i<list.size();i++){
		nodo.addChild(list.get(i),nodo);
		} 
		RESULT = nodo;

 :}
;


else_statement
	::= ELSE body:lista    {: 
		Node<String> nodo = new Node<String>("else");
		ArrayList<Node<String>> list= (ArrayList<Node<String>>) lista;
		for(int i=0;i<list.size();i++){
		nodo.addChild(list.get(i),nodo);
		} 
		RESULT = nodo;

 :}
;


composit_condition
	::= composit_condition OROR condition
	| composit_condition ANDAND condition 
	| condition
;

condition
	::= IDENTIFIER logic_operator IDENTIFIER
	|  IDENTIFIER logic_operator value_numeric
	|  value_numeric logic_operator IDENTIFIER
	|  IDENTIFIER logic_operator value_string
	|  value_string logic_operator IDENTIFIER
 	|  value_numeric logic_operator value_numeric
	|  value_string logic_operator value_string
;


logic_operator
	::= OROR | EQEQ | NOTEQ | ANDAND | ACEQUALS | AC | AO | AOEQ ;

body 
	::= BRACEO body:lista BRACEC {: ArrayList<Node<String>> list = (ArrayList<Node<String>>) lista; RESULT = list; :}
	| BRACEO composit_statement:lista BRACEC  {: ArrayList<Node<String>> list = (ArrayList<Node<String>>) lista; RESULT = list; :}
	| BRACEO BRACEC
;

declaration_statement
	::=type_def_numeric IDENTIFIER       {: /*System.out.println("declaration numeric");*/ :} 
	| type_def_string IDENTIFIER       {: /*System.out.println("declaration string");*/ :}
	| type_def_numeric IDENTIFIER:i TPEQ value_numeric:v {: /*System.out.println("declaration + initialization numeric  "+i+"="+v);*/ :}
	| type_def_string IDENTIFIER:i TPEQ value_string:v {: /*System.out.println("declaration + initialization string "+i+"="+v);*/ :}
 ;

assignment_statement
	::= IDENTIFIER TPEQ value_numeric  {: /*System.out.println("assignment numeric");*/ :} 
	| IDENTIFIER TPEQ value_string  {: /*System.out.println("assignment string");*/ :} 
	| IDENTIFIER TPEQ IDENTIFIER {: /*System.out.println("assignment");*/ :} 
	| IDENTIFIER EQ value_numeric  {: /*System.out.println("assignment numeric");*/ :} 
	| IDENTIFIER EQ value_string  {: /*System.out.println("assignment string");*/ :}
	| IDENTIFIER EQ IDENTIFIER {: /*System.out.println("assignment");*/ :} 
; 

value_numeric
	::= IMAGINARY_LITERAL:v   {: RESULT = v; :} 
	| HEX_LITERAL:v {: RESULT = v; :}
	| DECIMAL_LITERAL:v {: RESULT = v; :}
	| OCTAL_LITERAL:v {: RESULT = v; :}
	| FLOAT_LITERAL:v  {: RESULT = v; :}
;

value_string
	::= STRING_LITERAL:v {: RESULT = v; :} 
;

type_def_numeric
	::= INT32 
	| INT64
	| UINT
	| INT	
;

type_def_string
	::= STRING	
;




